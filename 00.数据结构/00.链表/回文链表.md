
## 题目
+ https://leetcode.cn/leetbook/read/linked-list/fov6t/

## 分析
```
+ 方法1：最直观的方法是将链表中每个节点的值保存在数组中, 然后数组头尾开始遍历元素(向中间靠)值是否相等.  -> 时间复杂度O(N), 空间复杂度O(N)
+ 方法2：先通过快慢指针找到链表的中间节点, 然后翻转后半段链表, 然后比对前后两半的链表是否相等.  -- 其中有一些小细节的处理  -> 时间复杂度O(N), 空间复杂度O(1)
+ 方法3：将链表放到栈中, 栈和原始链表进行对比 -> 时间复杂度O(N), 空间复杂度O(N)
+ 方法3：递归, 前面的题目(移除链表元素), 知道了可以从尾部处理链表的方法, 按照这个思路, 通过递归解决本问题.
	- 核心的思想还是先用递归, 到底链尾, 然后链尾和链头进行比对.
	- 挺有意思的, 具体细节未深究
```

## 实现


## 反馈


## 成果
+ 通过快慢指针找到链表中间节点的方法挺有意思 -- 快指针一次走两步, 慢指针一次走一步, 则快指针走到链表尾部时, 慢指针正好走到中间点. 
	- 奇数和偶数的链表处理细节需要注意

+ 单向的链表, 可以通过递归实现逆序打印, 真的挺神奇的
	- 当然本质还是借助了函数栈的结构.


